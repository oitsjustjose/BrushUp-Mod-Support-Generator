"""Author: oitsjustjose @ github/twitter/curseforge"""

import json
import os
import shutil

import cv2
import numpy as np
from blendmodes.blend import BlendType, blendLayers
from PIL import Image


def get_color_from_plank(plank_path: str) -> np.ndarray:
    """
    Gets the "best" color from a given plank at <plank_path> using the average of four methods:
        1. The color in the very center of the texture
        2. The average color, generated by taking the average of every pixel's RGB value
        3. The most dominant color in the texture, generated using K-Means clustering
        4. The least dominant color in the texture, generated using K-Means clustering
    Args:
        plank_path (str): the name of the plank texture file, including .png extension
    Returns: None
    """
    colors = []
    img: cv2.Mat = cv2.imread(plank_path)
    print(f"{plank_path} is {img.shape[1]}Ã—{img.shape[0]}")

    # Color @ Center
    rows, cols, _ = img.shape
    color = img[cols // 2, rows // 2]
    colors.append(color)

    # Average BGR Value for Whole Texture
    avg_color_per_row = np.average(img, axis=0)  # type: ignore
    avg_color = np.average(avg_color_per_row, axis=0)
    colors.append(avg_color)

    # K-Means Clustering
    pixels = np.float32(img.reshape(-1, 3))  # type: ignore
    n_colors = 16
    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 200, 0.1)
    flags = cv2.KMEANS_PP_CENTERS
    _, labels, palette = cv2.kmeans(pixels, n_colors, None, criteria, 10, flags)
    _, counts = np.unique(labels, return_counts=True)
    colors.append(palette[np.argmax(counts)])
    colors.append(palette[np.argmin(counts)])

    return np.concatenate((np.mean(colors, axis=0), [255]))


def generate_textures(modid: str, plank_path: str) -> None:
    """
    Generates the texture file for a given plank and a given mod
        Args:
            modid (str): the modid derived from the dirname in the textures dir
            plank (str): the name of the plank texture file, including .png extension
        Returns: None
    """

    def mat_to_pil(img: cv2.Mat) -> Image.Image:
        img = cv2.cvtColor(img, cv2.COLOR_BGRA2RGBA)
        img_pil = Image.fromarray(img, mode="RGBA")
        return img_pil

    plank_color = get_color_from_plank(f"./textures/{modid}/{plank_path}")

    for root, _, files in os.walk("./references/textures"):
        for reference_path in files:
            reference = cv2.imread(f"{root}/{reference_path}", cv2.IMREAD_UNCHANGED)

            # Create bitmask, apply and fill with plank color
            alpha = np.sum(reference, axis=-1) > 0
            overlay = reference.copy()
            overlay[alpha > 0] = plank_color

            overlay = mat_to_pil(overlay)
            ref_text = mat_to_pil(reference)
            # Ugh, why does overlay work so well -_-
            output = blendLayers(ref_text, overlay, BlendType.OVERLAY)

            out_plank = plank_path.replace("_planks", "").replace(".png", "")
            out_root = f"./out/assets/{modid}/{root.replace('./references', '')}"
            os.makedirs(out_root, exist_ok=True)

            output.save(f"{out_root}/{out_plank}{reference_path.replace('./', '')}")


def generate_data(modid: str, plank_path: str) -> None:
    """
    Generates the BlockStates and Models for the given plank variant for the given mod
        Args:
            modid (str): the modid derived from the dirname in the textures dir
            plank (str): the name of the plank texture file, including .png extension
        Returns: None
    """
    plank = plank_path.replace("_planks", "").replace(".png", "")
    # Skip over reading these as JSON, we can just do a dummy replace
    for dtype in ["blockstates", "models/block"]:
        for ref in os.listdir(f"./references/{dtype}"):
            root = f"./out/assets/{modid}/{dtype}"
            os.makedirs(root, exist_ok=True)

            with open(f"./references/{dtype}/{ref}", "r", encoding="utf-8") as handle:
                data = handle.read()

            data = data.replace("<MODID>", modid).replace("<PLANK>", plank)
            with open(
                f"./out/assets/{modid}/{dtype}/{plank}{ref}", "w", encoding="utf-8"
            ) as handle:
                handle.write(data)


def post_process(modid: str) -> None:
    """
    Performs post-processing tasks like renamining signs from <mat>_sign.png to <mat>.png
        Args:
            modid (str): the modid derived from the dirname in the textures dir
        Returns: None
    """
    # Make item models just in case
    os.makedirs(f"./out/assets/{modid}/models/item", exist_ok=True)
    for block_model in os.listdir(f"./out/assets/{modid}/models/block"):
        if not "_inventory" in block_model:
            continue
        in_world_model = block_model.replace("_inventory", "")
        path = f"./out/assets/{modid}/models/item/{in_world_model}"
        data = {"parent": f"{modid}:block/{block_model.replace('.json', '')}"}
        with open(path, "w", encoding="utf-8") as handle:
            handle.write(json.dumps(data))

    signs_root = f"./out/assets/{modid}/textures/entity/signs/"
    for sign in os.listdir(signs_root):
        new_name = sign.replace("_sign", "")
        os.rename(f"{signs_root}/{sign}", f"{signs_root}/{new_name}")


def main() -> None:
    """
    Iters over all textures, generates textures, blockstates & models
        Args: None
        Returns: None
    """
    if os.path.exists("./out"):
        shutil.rmtree("./out")

    for modid in os.listdir("./textures"):
        if not os.path.isdir(f"./textures/{modid}"):
            print(f"[i] ./textures/{modid} is not a directory: skipping")
            continue

        for plank in os.listdir(f"./textures/{modid}"):
            generate_textures(modid, plank)
            generate_data(modid, plank)

        post_process(modid)

    for modid in os.listdir("./overrides"):
        if not os.path.isdir(f"./overrides/{modid}"):
            print(f"[i] ./overrides/{modid} is not a directory: skipping")
            continue
        for texture in os.listdir(f"./overrides/{modid}"):
            if not os.path.exists(f"./out/assets/{modid}/textures/block/"):
                os.makedirs(f"./out/assets/{modid}/textures/block/", exist_ok=True)
            shutil.copyfile(
                f"./overrides/{modid}/{texture}",
                f"./out/assets/{modid}/textures/block/{texture}",
            )


if __name__ == "__main__":
    main()
